/*********************************************************************************
 * BTTM v1.9.1 - Brake & Tire Temperature Monitor
 * Production Release - November 2025
 * 
 * SYSTEM OVERVIEW:
 * ---------------
 * • 8-Node CAN Network: 4 Tire + 4 Brake temperature sensors
 * • ESP32-S3 Central Controller with dual-core FreeRTOS
 * • u-blox Neo M8 GNSS for position/speed tracking
 * • ILI9341 TFT display with 8x8 grid layout
 * • SD card data logging (CSV format)
 * • WiFi web interface with real-time charts
 * 
 * HARDWARE CONFIGURATION:
 * ----------------------
 * MCU: ESP32-S3 WROOM-2-N16R8 (16MB Flash, 8MB PSRAM)
 * Display: 320x240 ILI9341 TFT (SPI)
 * GNSS: u-blox Neo M8 (UART @ 115200 baud)
 * CAN: TWAI @ 500 kbps (8 nodes)
 * Storage: microSD card (SPI, shared bus with TFT)
 * WiFi: 2.4GHz (web server on port 80)
 * 
 * VERSION HISTORY:
 * ---------------
 * v1.9.1 (Dec 2025)
 *   • CRITICAL FIX: Corrected Brakes IDs from 0x461–0x464 to 0x455-0x458
 *
 * v1.9.0 (Nov 2025) - PRODUCTION RELEASE
 *   • CRITICAL FIX: Corrected GNSS UART pins for PCB wiring
 *     - GPIO17 (TX) → Neo M8 RX Pin 21
 *     - GPIO18 (RX) ← Neo M8 TX Pin 20
 *   • Removed verbose debugging output
 *   • Optimized task stack sizes
 *   • Cleaned code for production deployment
 *   • Verified stable operation with all 8 CAN nodes
 * 
 * v1.8.1 (Nov 2025)
 *   • New TFT layout: Rear row inverted (color above temp)
 *   • WiFi status display restored
 *   • IP address shown on TFT at startup (bit quick but fine for now)
 * 
 * v1.7.12 (Nov 2025)
 *   • Time range selection: 10s/20s/60s/120s
 *   • Individual sensor line visibility toggles
 *   • Web interface improvements
 * 
 * PERFORMANCE SPECS:
 * -----------------
 * CAN Bus: 50 Hz per sensor (400 msgs/sec total)
 * GNSS: 5 Hz update rate
 * Display: 4 Hz refresh rate
 * SD Logging: 5 Hz (synchronized with GNSS)
 * Web Update: 2 Hz
 * 
 * AUTHOR: Pietro Gambarin
 * LICENSE: MIT
 *********************************************************************************/

#include <SPI.h>
#include <SD.h>
#include <WiFi.h>
#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ILI9341.h>
#include "driver/twai.h"
#include <SparkFun_u-blox_GNSS_Arduino_Library.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/semphr.h>
#include <math.h>

// ========================================================================
// CONFIGURATION
// ========================================================================

// --- WiFi Credentials ---
const char* ssid = "empty"; // Your SSID here
const char* password = "empty"; // Your Password here

// --- Pin Assignments ---
#define HEARTBEAT_LED 48

// TFT Display (VSPI)
#define TFT_SCLK 40
#define TFT_MISO 41
#define TFT_MOSI 42
#define TFT_CS   14
#define TFT_DC   47
#define TFT_RST  21

// SD Card (shares VSPI with TFT)
#define SD_CS_PIN 10

// CAN Bus (TWAI peripheral)
#define CAN_TX_PIN 4
#define CAN_RX_PIN 15

// GNSS Module (UART2)
// CRITICAL: These pins match actual PCB routing
//   Neo M8 Pin 20 (TX) → ESP32 GPIO18 (RX)
//   Neo M8 Pin 21 (RX) ← ESP32 GPIO17 (TX)
#define GNSS_RX_PIN 18  // ESP32 receives from Neo M8 TX
#define GNSS_TX_PIN 17  // ESP32 transmits to Neo M8 RX
#define GNSS_SERIAL Serial2
#define GNSS_BAUD 115200

// --- CAN Message IDs ---
// Temperature data format: Big-Endian int16 (value * 100)
// Example: 25.5°C = 2550 = 0x09F6 → [0x09, 0xF6]

// Tire Sensors (Front Left, Front Right, Rear Left, Rear Right)
#define CAN_ID_TIRE_FL 0x451
#define CAN_ID_TIRE_FR 0x452
#define CAN_ID_TIRE_RL 0x453
#define CAN_ID_TIRE_RR 0x454

// Brake Sensors (Front Left, Front Right, Rear Left, Rear Right)
#define CAN_ID_BRAKE_FL 0x455
#define CAN_ID_BRAKE_FR 0x456
#define CAN_ID_BRAKE_RL 0x457
#define CAN_ID_BRAKE_RR 0x458

// --- Display Configuration ---
#define FLASH_INTERVAL 250      // ms (for high-temp warning flash)
#define TEMP_TEXT_SIZE 3        // Font size for temperature numbers

// --- Task Timing ---
#define SENSOR_LOG_TASK_PERIOD 10       // ms (100 Hz task rate)
#define DISPLAY_UPDATE_TASK_PERIOD 250  // ms (4 Hz display refresh)

// --- Task Stack Sizes ---
#define SENSOR_LOG_TASK_STACK 8192      // bytes
#define DISPLAY_UPDATE_TASK_STACK 6144  // bytes
#define SENSOR_LOG_TASK_PRIORITY 4      // Higher = more important
#define DISPLAY_UPDATE_TASK_PRIORITY 2

// --- CAN Bus Configuration ---
#define CAN_BURST_DRAIN 32      // Max messages to process per loop
#define CAN_RX_TIMEOUT_MS 1     // Timeout for CAN receive

// --- SD Card Configuration ---
#define SD_SPI_FREQ 25000000    // 25 MHz SPI clock
#define SD_FLUSH_LINES 50       // Flush after N lines
#define SD_FLUSH_INTERVAL_MS 3000  // Or after N milliseconds

// --- JSON Buffer Size ---
#define JSON_BUF_SZ 1024        // For web API responses

// ========================================================================
// DATA STRUCTURES
// ========================================================================

// Shared data protected by mutex (accessed by both cores)
typedef struct {
    // Brake temperature data (CAN)
    float brakeCurrent[4];      // Current readings [°C]
    float brakeMax[4];          // Session maximum [°C]
    float brakeMin[4];          // Session minimum [°C]
    float brakeSum[4];          // For averaging
    float brakeSumSquares[4];   // For standard deviation
    long brakeReadingCounts[4]; // Sample count
    
    // Tire temperature data (CAN)
    float tireCurrent[4];       // Current readings [°C]
    float tireMax[4];           // Session maximum [°C]
    float tireMin[4];           // Session minimum [°C]
    float tireSum[4];           // For averaging
    float tireSumSquares[4];    // For standard deviation
    long tireReadingCounts[4];  // Sample count
    
    // GNSS data
    int32_t lat_raw;            // Latitude (1e-7 degrees)
    int32_t lon_raw;            // Longitude (1e-7 degrees)
    float speed_kph;            // Ground speed [km/h]
    uint8_t sats;               // Satellite count
    float pdop;                 // Position Dilution of Precision
    bool gnssValid;             // Fix type >= 2D
    bool newPVTAvailable;       // New position data flag
    unsigned long lastPVTTime;  // Timestamp of last update
} SharedData_t;

// TFT cell positions
struct CellPos { int16_t x, y; };
struct Rect    { int16_t x, y, w, h; };

// ========================================================================
// GLOBAL OBJECTS
// ========================================================================

AsyncWebServer server(80);
Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC, TFT_RST);
SFE_UBLOX_GNSS myGNSS;

// ========================================================================
// GLOBAL VARIABLES
// ========================================================================

SharedData_t sharedData;
SemaphoreHandle_t dataMutex;
TaskHandle_t sensorLogTaskHandle = NULL;
TaskHandle_t displayUpdateTaskHandle = NULL;

char logFileName[24];
File logFile;
uint16_t bufferedLines = 0;
unsigned long lastFlushMs = 0;

bool isSdCardAvailable = false;
bool gnssConfigured = false;
bool isCanBusOk = false;

const int FL_INDEX = 0, FR_INDEX = 1, RL_INDEX = 2, RR_INDEX = 3;

// TFT layout arrays
CellPos tireTextPos[4];
CellPos brakeTextPos[4];
Rect    tireColorCell[4];
Rect    brakeColorCell[4];

char prevTireStrings[4][8];
char prevBrakeStrings[4][8];
bool flashState = false;
const char *version_text = "BTTM v1.9.1";

// ========================================================================
// WEB INTERFACE HTML
// ========================================================================

const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML><html>
<head>
  <title>BTTM v1.9.1 Live</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
  :root { --card-h: 260px; }
  body { font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif; background:#121212; color:#e0e0e0; margin:0; padding:20px;}
  .container { max-width:1200px; margin:0 auto;}
  h2 { text-align:center; color:#bb86fc; }
  .grid { display:grid; grid-template-columns: repeat(3, minmax(280px, 1fr)); gap:20px; align-items:start; }
  .card { background:#1e1e1e; border-radius:8px; padding:20px; box-shadow:0 4px 8px rgba(0,0,0,0.3);}
  .card h3 { margin-top:0; color:#03dac6;}
  .temp-grid { display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-top:15px;}
  .temp-item { text-align:center;}
  .temp-item .label { font-size:.9em; color:#cfcfcf;}
  .temp-item .value { font-size:2.2em; font-weight:bold;}
  .gps-item { display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #333;}
  .gps-item:last-child { border-bottom:none;}
  table { width:100%; border-collapse:collapse; margin-top:15px;}
  th,td { padding:8px; text-align:center; border:1px solid #444;}
  th { background:#333; color:#03dac6;}
  .log-list { list-style:none; padding:0; margin:0;}
  .log-item { display:flex; justify-content:space-between; align-items:center; padding:8px 0; border-bottom:1px solid #333;}
  .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center;}
  .btn { background:#03a9f4; color:#000; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; font-weight:600;}
  .btn:disabled { opacity:.5; cursor:not-allowed;}
  .btn.active { background:#bb86fc; color:#000; }
  .chart-controls { display:flex; gap:15px; margin-bottom:12px; flex-wrap:wrap; align-items:center; }
  .time-btns { display:flex; gap:6px; }
  .time-btn { background:#333; color:#e0e0e0; border:none; padding:6px 12px; border-radius:4px; cursor:pointer; font-size:0.9em; }
  .time-btn.active { background:#03dac6; color:#000; font-weight:600; }
  .line-toggles { display:flex; gap:12px; flex-wrap:wrap; }
  .toggle-item { display:flex; align-items:center; gap:6px; cursor:pointer; user-select:none; }
  .toggle-item input[type="checkbox"] { cursor:pointer; width:16px; height:16px; }
  .toggle-item label { cursor:pointer; font-size:0.9em; }
  .footer { text-align:center; margin-top:30px; font-size:0.8em; color:#777;}
  a { color:#03dac6; text-decoration:none; }

  /* Charts */
  .span-3 { grid-column: 1 / span 3; }
  .chart-wrap { position:relative; height:var(--card-h); }
  canvas.chart { width:100%; height:100%; background:#0e0e0e; border:1px solid #333; border-radius:6px; display:block; }

  .legend { display:flex; gap:12px; flex-wrap:wrap; margin-top:8px; font-size:.9em; color:#cfcfcf;}
  .lg { display:flex; align-items:center; gap:6px;}
  .sw { width:14px; height:3px; display:inline-block; }
  .sw.fl { background:#42a5f5; }
  .sw.fr { background:#ef5350; }
  .sw.rl { background:#66bb6a; }
  .sw.rr { background:#ffa726; }

  /* TFT-style colour cells */
  .color-grid { display:grid; grid-template-columns: repeat(4, 1fr); gap:12px; margin-top:10px; }
  .color-row-title { margin-top:8px; color:#cfcfcf; font-size:.95em; }
  .cellbox { position:relative; height:74px; border:1px solid #333; border-radius:6px; overflow:hidden; }
  .cellbox .tag { position:absolute; top:6px; left:8px; font-size:.85em; color:#e0e0e0; text-shadow:0 1px 2px rgba(0,0,0,.6); }
  .cellbox .val { position:absolute; right:8px; bottom:6px; font-weight:700; }

  @media (max-width: 980px) {
    .grid { grid-template-columns: 1fr; }
    .span-3 { grid-column: 1 / span 1; }
  }
  </style>
</head>
<body>
  <div class="container">
    <h2>Brake & Tire Temperature Monitor v1.9.1</h2>

    <div class="grid">
      <div class="card">
        <h3>Brake Temperatures (&deg;C)</h3>
        <div class="temp-grid">
          <div class="temp-item"><div class="label">Front Left</div><div class="value" id="br_fl_temp">--.-</div></div>
          <div class="temp-item"><div class="label">Front Right</div><div class="value" id="br_fr_temp">--.-</div></div>
          <div class="temp-item"><div class="label">Rear Left</div><div class="value" id="br_rl_temp">--.-</div></div>
          <div class="temp-item"><div class="label">Rear Right</div><div class="value" id="br_rr_temp">--.-</div></div>
        </div>
      </div>

      <div class="card">
        <h3>Tire Temperatures (&deg;C)</h3>
        <div class="temp-grid">
          <div class="temp-item"><div class="label">Front Left</div><div class="value" id="ti_fl_temp">--.-</div></div>
          <div class="temp-item"><div class="label">Front Right</div><div class="value" id="ti_fr_temp">--.-</div></div>
          <div class="temp-item"><div class="label">Rear Left</div><div class="value" id="ti_rl_temp">--.-</div></div>
          <div class="temp-item"><div class="label">Rear Right</div><div class="value" id="ti_rr_temp">--.-</div></div>
        </div>
      </div>

      <div class="card">
        <h3>GNSS Data</h3>
        <div class="gps-item"><span>Satellites</span><span id="sats">--</span></div>
        <div class="gps-item"><span>Speed (km/h)</span><span id="speed">--.-</span></div>
        <div class="gps-item"><span>Latitude</span><span id="lat">--.------</span></div>
        <div class="gps-item"><span>Longitude</span><span id="lon">--.------</span></div>
        <div class="gps-item"><span>PDOP</span><span id="pdop">--.--</span></div>
      </div>

      <div class="card span-3">
        <h3>Tires - Live Graph</h3>
        <div class="chart-controls">
          <div class="time-btns">
            <button class="time-btn" onclick="setTireTime(10)">10s</button>
            <button class="time-btn" onclick="setTireTime(20)">20s</button>
            <button class="time-btn" onclick="setTireTime(60)">60s</button>
            <button class="time-btn active" onclick="setTireTime(120)">120s</button>
          </div>
          <div class="line-toggles">
            <div class="toggle-item"><input type="checkbox" id="ti_fl_vis" checked onchange="toggleTireLine('fl')"><label for="ti_fl_vis">FL</label></div>
            <div class="toggle-item"><input type="checkbox" id="ti_fr_vis" checked onchange="toggleTireLine('fr')"><label for="ti_fr_vis">FR</label></div>
            <div class="toggle-item"><input type="checkbox" id="ti_rl_vis" checked onchange="toggleTireLine('rl')"><label for="ti_rl_vis">RL</label></div>
            <div class="toggle-item"><input type="checkbox" id="ti_rr_vis" checked onchange="toggleTireLine('rr')"><label for="ti_rr_vis">RR</label></div>
          </div>
        </div>
        <div class="chart-wrap"><canvas id="ti_chart" class="chart"></canvas></div>
        <div class="legend">
          <span class="lg"><span class="sw fl"></span>FL</span>
          <span class="lg"><span class="sw fr"></span>FR</span>
          <span class="lg"><span class="sw rl"></span>RL</span>
          <span class="lg"><span class="sw rr"></span>RR</span>
        </div>
      </div>

      <div class="card span-3">
        <h3>Brakes - Live Graph</h3>
        <div class="chart-controls">
          <div class="time-btns">
            <button class="time-btn" onclick="setBrakeTime(10)">10s</button>
            <button class="time-btn" onclick="setBrakeTime(20)">20s</button>
            <button class="time-btn" onclick="setBrakeTime(60)">60s</button>
            <button class="time-btn active" onclick="setBrakeTime(120)">120s</button>
          </div>
          <div class="line-toggles">
            <div class="toggle-item"><input type="checkbox" id="br_fl_vis" checked onchange="toggleBrakeLine('fl')"><label for="br_fl_vis">FL</label></div>
            <div class="toggle-item"><input type="checkbox" id="br_fr_vis" checked onchange="toggleBrakeLine('fr')"><label for="br_fr_vis">FR</label></div>
            <div class="toggle-item"><input type="checkbox" id="br_rl_vis" checked onchange="toggleBrakeLine('rl')"><label for="br_rl_vis">RL</label></div>
            <div class="toggle-item"><input type="checkbox" id="br_rr_vis" checked onchange="toggleBrakeLine('rr')"><label for="br_rr_vis">RR</label></div>
          </div>
        </div>
        <div class="chart-wrap"><canvas id="br_chart" class="chart"></canvas></div>
        <div class="legend">
          <span class="lg"><span class="sw fl"></span>FL</span>
          <span class="lg"><span class="sw fr"></span>FR</span>
          <span class="lg"><span class="sw rl"></span>RL</span>
          <span class="lg"><span class="sw rr"></span>RR</span>
        </div>
      </div>

      <div class="card span-3">
        <h3>TFT Colour Cells</h3>
        <div class="color-row-title">Front</div>
        <div class="color-grid">
          <div id="c_ti_fl" class="cellbox"><span class="tag">FL Tire</span><span class="val" id="v_ti_fl">--</span></div>
          <div id="c_br_fl" class="cellbox"><span class="tag">FL Brake</span><span class="val" id="v_br_fl">--</span></div>
          <div id="c_br_fr" class="cellbox"><span class="tag">FR Brake</span><span class="val" id="v_br_fr">--</span></div>
          <div id="c_ti_fr" class="cellbox"><span class="tag">FR Tire</span><span class="val" id="v_ti_fr">--</span></div>
        </div>
        <div class="color-row-title">Rear</div>
        <div class="color-grid">
          <div id="c_ti_rl" class="cellbox"><span class="tag">RL Tire</span><span class="val" id="v_ti_rl">--</span></div>
          <div id="c_br_rl" class="cellbox"><span class="tag">RL Brake</span><span class="val" id="v_br_rl">--</span></div>
          <div id="c_br_rr" class="cellbox"><span class="tag">RR Brake</span><span class="val" id="v_br_rr">--</span></div>
          <div id="c_ti_rr" class="cellbox"><span class="tag">RR Tire</span><span class="val" id="v_ti_rr">--</span></div>
        </div>
      </div>

      <div class="card">
        <h3>Brakes Statistics (&deg;C)</h3>
        <table>
          <tr><th>Location</th><th>Avg</th><th>Max</th><th>Min</th><th>Std Dev</th></tr>
          <tr><td>Front Left</td><td id="br_fl_avg">--.-</td><td id="br_fl_max">--.-</td><td id="br_fl_min">--.-</td><td id="br_fl_std">--.-</td></tr>
          <tr><td>Front Right</td><td id="br_fr_avg">--.-</td><td id="br_fr_max">--.-</td><td id="br_fr_min">--.-</td><td id="br_fr_std">--.-</td></tr>
          <tr><td>Rear Left</td><td id="br_rl_avg">--.-</td><td id="br_rl_max">--.-</td><td id="br_rl_min">--.-</td><td id="br_rl_std">--.-</td></tr>
          <tr><td>Rear Right</td><td id="br_rr_avg">--.-</td><td id="br_rr_max">--.-</td><td id="br_rr_min">--.-</td><td id="br_rr_std">--.-</td></tr>
        </table>
      </div>

      <div class="card">
        <h3>Tires Statistics (&deg;C)</h3>
        <table>
          <tr><th>Location</th><th>Avg</th><th>Max</th><th>Min</th><th>Std Dev</th></tr>
          <tr><td>Front Left</td><td id="ti_fl_avg">--.-</td><td id="ti_fl_max">--.-</td><td id="ti_fl_min">--.-</td><td id="ti_fl_std">--.-</td></tr>
          <tr><td>Front Right</td><td id="ti_fr_avg">--.-</td><td id="ti_fr_max">--.-</td><td id="ti_fr_min">--.-</td><td id="ti_fr_std">--.-</td></tr>
          <tr><td>Rear Left</td><td id="ti_rl_avg">--.-</td><td id="ti_rl_max">--.-</td><td id="ti_rl_min">--.-</td><td id="ti_rl_std">--.-</td></tr>
          <tr><td>Rear Right</td><td id="ti_rr_avg">--.-</td><td id="ti_rr_max">--.-</td><td id="ti_rr_min">--.-</td><td id="ti_rr_std">--.-</td></tr>
        </table>
      </div>

      <div class="card">
        <h3>SD Card Logs</h3>
        <ul id="log-list" class="log-list"><li>Loading...</li></ul>
      </div>

      <div class="card">
        <h3>System</h3>
        <div class="row">
          <button class="btn" id="rebootBtn">Reboot Device</button>
          <span id="rebootMsg"></span>
        </div>
      </div>
    </div>

    <div class="footer">Cadence BTTM v1.9.1 - Production Release - Pietro Gambarin © 2025</div>
  </div>

<script>
const STEP_MS=500;
let TIRE_WINDOW_S=120;
let BRAKE_WINDOW_S=120;
const MAXPTS=Math.floor(240*1000/STEP_MS);

const tireVis = {fl:true, fr:true, rl:true, rr:true};
const brakeVis = {fl:true, fr:true, rl:true, rr:true};

function makeSeries(){ return []; }
const ti = { fl:makeSeries(), fr:makeSeries(), rl:makeSeries(), rr:makeSeries() };
const br = { fl:makeSeries(), fr:makeSeries(), rl:makeSeries(), rr:makeSeries() };

function push(series, v){
  const val = Number.isFinite(v) ? v : null;
  series.push({t:Date.now(), v:val});
  if(series.length>MAXPTS) series.shift();
}

function setTireTime(seconds) {
  TIRE_WINDOW_S = seconds;
  document.querySelectorAll('.card:nth-of-type(4) .time-btn').forEach(btn => {
    btn.classList.remove('active');
    if(btn.textContent === seconds+'s') btn.classList.add('active');
  });
}

function setBrakeTime(seconds) {
  BRAKE_WINDOW_S = seconds;
  document.querySelectorAll('.card:nth-of-type(5) .time-btn').forEach(btn => {
    btn.classList.remove('active');
    if(btn.textContent === seconds+'s') btn.classList.add('active');
  });
}

function toggleTireLine(line) {
  tireVis[line] = document.getElementById('ti_'+line+'_vis').checked;
}

function toggleBrakeLine(line) {
  brakeVis[line] = document.getElementById('br_'+line+'_vis').checked;
}

function drawChart(canvas, seriesMap, windowS, visMap){
  const ctx = canvas.getContext('2d');
  const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
  if (canvas.width !== cssW || canvas.height !== cssH){ canvas.width=cssW; canvas.height=cssH; }
  const w=canvas.width, h=canvas.height;

  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#0e0e0e"; ctx.fillRect(0,0,w,h);

  const now = Date.now();
  const tMin = now - windowS*1000;

  let yMin=+Infinity, yMax=-Infinity;
  const keys = Object.keys(seriesMap).filter(k => visMap[k]);
  const vis = {};
  keys.forEach(k=>{
    vis[k]=seriesMap[k].filter(p=>p.t>=tMin);
    vis[k].forEach(p=>{ if(p.v!=null){ if(p.v<yMin)yMin=p.v; if(p.v>yMax)yMax=p.v; }});
  });
  if(!isFinite(yMin) || !isFinite(yMax)){ yMin=0; yMax=100; }
  if (yMax===yMin){ yMax=yMin+1; }
  const pad = (yMax-yMin)*0.1; yMin=Math.max(0,yMin-pad); yMax=yMax+pad;

  const L=44,R=10,T=10,B=24;
  ctx.strokeStyle="#444"; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(L,T); ctx.lineTo(L,h-B); ctx.lineTo(w-R,h-B); ctx.stroke();

  ctx.fillStyle="#aaa"; ctx.font="10px system-ui";
  for(let i=0;i<=5;i++){
    const yv = yMin+(yMax-yMin)*i/5;
    const y = mapY(yv);
    ctx.strokeStyle="#222"; ctx.beginPath(); ctx.moveTo(L,y); ctx.lineTo(w-R,y); ctx.stroke();
    ctx.fillText(yv.toFixed(0), 4, y+3);
  }
  
  const tickInterval = windowS <= 20 ? 5 : windowS <= 60 ? 10 : 20;
  for(let s=0; s<=windowS; s+=tickInterval){
    const tx = now - s*1000;
    const x = mapX(tx);
    ctx.strokeStyle="#222"; ctx.beginPath(); ctx.moveTo(x,h-B); ctx.lineTo(x,T); ctx.stroke();
    ctx.fillText((windowS-s)+"s", x-10, h-6);
  }

  const colorMap = {fl:"#42a5f5", fr:"#ef5350", rl:"#66bb6a", rr:"#ffa726"};
  ctx.lineWidth=2;
  keys.forEach(k=>{
    const pts = vis[k];
    if(pts.length<2) return;
    ctx.strokeStyle = colorMap[k] || "#fff";
    ctx.beginPath();
    let started=false;
    for(let i=0;i<pts.length;i++){
      const p=pts[i];
      if(p.v==null){ started=false; continue; }
      const x = mapX(p.t), y = mapY(p.v);
      if(!started){ ctx.moveTo(x,y); started=true; } else ctx.lineTo(x,y);
    }
    ctx.stroke();
  });

  function mapX(t){ return L + (t - tMin)*(w-R-L)/(windowS*1000); }
  function mapY(v){ return (h-B) - (v - yMin)*(h-B-T)/(yMax-yMin); }
}

function loadLogs() {
  fetch('/logslist').then(r=>r.json()).then(data=>{
    const list=document.getElementById('log-list'); list.innerHTML='';
    if(!data.length){ list.innerHTML='<li>No logs found.</li>'; return; }
    data.forEach(file=>{
      const li=document.createElement('li'); li.className='log-item';
      li.innerHTML = '<strong>'+file+'</strong> <span><a href="/view?file='+encodeURIComponent(file)+'" target="_blank">View</a> | <a href="/download?file='+encodeURIComponent(file)+'">Download</a></span>';
      list.appendChild(li);
    });
  }).catch(_=>{document.getElementById('log-list').innerHTML='<li>Error loading logs.</li>';});
}

document.getElementById('rebootBtn').addEventListener('click', ()=>{
  const btn = document.getElementById('rebootBtn');
  const msg = document.getElementById('rebootMsg');
  btn.disabled = true; msg.textContent = 'Rebooting...';
  fetch('/reboot', {method:'POST'}).then(_=>{
    msg.textContent = 'Reboot command sent. Device will restart.';
  }).catch(_=>{
    msg.textContent = 'Failed to send reboot.';
  });
});

const tiCanvas = document.getElementById('ti_chart');
const brCanvas = document.getElementById('br_chart');

function tempColor(t){
  if(!Number.isFinite(t)) return '#202020';
  if (t <= 50)  return '#2196f3';
  if (t <= 100) return '#4caf50';
  if (t <= 200) return '#ffa200';
  if (t <= 300) return '#f44336';
  return '#f44336';
}
function setCell(id, val, flashHot){
  const el = document.getElementById(id);
  const vs = document.getElementById('v_'+id.split('_')[1]+'_'+id.split('_')[2]);
  if(!el || !vs) return;
  const t = Number.isFinite(val) ? Math.round(val) : null;
  const blink = flashHot && (Math.floor(Date.now()/250)%2===0);
  el.style.background = blink ? '#000000' : tempColor(val);
  vs.textContent = (t===null) ? '--' : String(t);
}

setInterval(()=>{
  fetch('/data').then(r=>r.json()).then(d=>{
    ['fl','fr','rl','rr'].forEach(k=>{
      document.getElementById('br_'+k+'_temp').textContent=d['br_'+k+'_temp'];
      document.getElementById('br_'+k+'_avg').textContent=d['br_'+k+'_avg'];
      document.getElementById('br_'+k+'_max').textContent=d['br_'+k+'_max'];
      document.getElementById('br_'+k+'_min').textContent=d['br_'+k+'_min'];
      document.getElementById('br_'+k+'_std').textContent=d['br_'+k+'_std'];
      document.getElementById('ti_'+k+'_temp').textContent=d['ti_'+k+'_temp'];
      document.getElementById('ti_'+k+'_avg').textContent=d['ti_'+k+'_avg'];
      document.getElementById('ti_'+k+'_max').textContent=d['ti_'+k+'_max'];
      document.getElementById('ti_'+k+'_min').textContent=d['ti_'+k+'_min'];
      document.getElementById('ti_'+k+'_std').textContent=d['ti_'+k+'_std'];
    });
    document.getElementById('sats').textContent=d.sats;
    document.getElementById('speed').textContent=d.speed;
    document.getElementById('lat').textContent=d.lat;
    document.getElementById('lon').textContent=d.lon;
    document.getElementById('pdop').textContent=d.pdop;

    const f = (x)=>{ const v=parseFloat(x); return Number.isFinite(v)?v:NaN; };

    const ti_fl=f(d.ti_fl_temp), ti_fr=f(d.ti_fr_temp), ti_rl=f(d.ti_rl_temp), ti_rr=f(d.ti_rr_temp);
    push(ti.fl, ti_fl); push(ti.fr, ti_fr); push(ti.rl, ti_rl); push(ti.rr, ti_rr);

    const br_fl=f(d.br_fl_temp), br_fr=f(d.br_fr_temp), br_rl=f(d.br_rl_temp), br_rr=f(d.br_rr_temp);
    push(br.fl, br_fl); push(br.fr, br_fr); push(br.rl, br_rl); push(br.rr, br_rr);

    drawChart(tiCanvas, ti, TIRE_WINDOW_S, tireVis);
    drawChart(brCanvas, br, BRAKE_WINDOW_S, brakeVis);

    setCell('c_ti_fl', ti_fl, ti_fl>300);
    setCell('c_br_fl', br_fl, br_fl>300);
    setCell('c_br_fr', br_fr, br_fr>300);
    setCell('c_ti_fr', ti_fr, ti_fr>300);

    setCell('c_ti_rl', ti_rl, ti_rl>300);
    setCell('c_br_rl', br_rl, br_rl>300);
    setCell('c_br_rr', br_rr, br_rr>300);
    setCell('c_ti_rr', ti_rr, ti_rr>300);
  }).catch(_=>{});
}, 500);

window.addEventListener('resize', ()=>{
  drawChart(tiCanvas, ti, TIRE_WINDOW_S, tireVis);
  drawChart(brCanvas, br, BRAKE_WINDOW_S, brakeVis);
});

loadLogs(); setInterval(loadLogs, 10000);
</script>
</body></html>
)rawliteral";

// ========================================================================
// UTILITY FUNCTIONS
// ========================================================================

void initializeSharedData() {
    for (int i = 0; i < 4; i++) {
        sharedData.brakeCurrent[i] = NAN;
        sharedData.brakeMax[i] = -999.0f;
        sharedData.brakeMin[i] = 999.0f;
        sharedData.brakeSum[i] = 0.0f;
        sharedData.brakeSumSquares[i] = 0.0f;
        sharedData.brakeReadingCounts[i] = 0;
        
        sharedData.tireCurrent[i] = NAN;
        sharedData.tireMax[i] = -999.0f;
        sharedData.tireMin[i] = 999.0f;
        sharedData.tireSum[i] = 0.0f;
        sharedData.tireSumSquares[i] = 0.0f;
        sharedData.tireReadingCounts[i] = 0;
    }
    sharedData.lat_raw = 0;
    sharedData.lon_raw = 0;
    sharedData.speed_kph = 0.0f;
    sharedData.sats = 0;
    sharedData.pdop = 99.99f;
    sharedData.gnssValid = false;
    sharedData.newPVTAvailable = false;
    sharedData.lastPVTTime = 0;
}

int findNextLogNumber() {
    int maxLogNum = 0;
    File root = SD.open("/");
    if (!root) return 1;
    File file = root.openNextFile();
    while (file) {
        const char* fileName = file.name();
        if (!file.isDirectory() && strncmp(fileName, "log_", 4) == 0 && strstr(fileName, ".csv") != NULL) {
            char numStr[5];
            strncpy(numStr, fileName + 4, 4);
            numStr[4] = '\0';
            bool isNumeric = true;
            for (int i = 0; i < 4; i++) {
                if (!isdigit(numStr[i])) { isNumeric = false; break; }
            }
            if (isNumeric) {
                int currentLogNum = atoi(numStr);
                if (currentLogNum > maxLogNum) maxLogNum = currentLogNum;
            }
        }
        file.close();
        file = root.openNextFile();
    }
    root.close();
    return maxLogNum + 1;
}

bool initializeSDCard() {
    Serial.println("Initializing SPI SD card...");
    if (!SD.begin(SD_CS_PIN, SPI, SD_SPI_FREQ)) {
        Serial.println("SD Card initialization failed!");
        return false;
    }
    
    Serial.println("SD Card initialized successfully");
    int logNumber = findNextLogNumber();
    sprintf(logFileName, "/log_%04d.csv", logNumber);
    
    logFile = SD.open(logFileName, FILE_WRITE);
    if (logFile) {
        logFile.println("Date,Timestamp,BrakeFR,BrakeFL,BrakeRR,BrakeRL,TireFR,TireFL,TireRR,TireRL,Latitude,Longitude,SpeedKPH,Satellites,PDOP");
        bufferedLines = 0;
        lastFlushMs = millis();
        Serial.printf("Created log file: %s\n", logFileName);
        return true;
    } else {
        Serial.printf("Failed to create log file: %s\n", logFileName);
        return false;
    }
}

bool configureGNSS_5Hz() {
    GNSS_SERIAL.begin(GNSS_BAUD, SERIAL_8N1, GNSS_RX_PIN, GNSS_TX_PIN);
    if (!myGNSS.begin(GNSS_SERIAL)) {
        GNSS_SERIAL.end();
        vTaskDelay(pdMS_TO_TICKS(100));
        GNSS_SERIAL.begin(9600, SERIAL_8N1, GNSS_RX_PIN, GNSS_TX_PIN);
        if (!myGNSS.begin(GNSS_SERIAL)) {
            Serial.println("FATAL: GNSS not detected");
            return false;
        }
        myGNSS.setSerialRate(GNSS_BAUD);
        vTaskDelay(pdMS_TO_TICKS(300));
        GNSS_SERIAL.end();
        vTaskDelay(pdMS_TO_TICKS(100));
        GNSS_SERIAL.begin(GNSS_BAUD, SERIAL_8N1, GNSS_RX_PIN, GNSS_TX_PIN);
    }
    myGNSS.setNavigationFrequency(5);
    myGNSS.saveConfiguration();
    vTaskDelay(pdMS_TO_TICKS(500));
    return true;
}

int tireIdToIndex(uint32_t id) {
    switch (id) {
        case CAN_ID_TIRE_FL: return FL_INDEX;
        case CAN_ID_TIRE_FR: return FR_INDEX;
        case CAN_ID_TIRE_RL: return RL_INDEX;
        case CAN_ID_TIRE_RR: return RR_INDEX;
        default: return -1;
    }
}

int brakeIdToIndex(uint32_t id) {
    switch (id) {
        case CAN_ID_BRAKE_FL: return FL_INDEX;
        case CAN_ID_BRAKE_FR: return FR_INDEX;
        case CAN_ID_BRAKE_RL: return RL_INDEX;
        case CAN_ID_BRAKE_RR: return RR_INDEX;
        default: return -1;
    }
}

bool decodeTempBE_i16x100(const twai_message_t &msg, float &outC) {
    if (msg.data_length_code < 2) return false;
    int16_t raw = ((int16_t)msg.data[0] << 8) | msg.data[1];
    outC = (float)raw / 100.0f;
    return true;
}

// ========================================================================
// JSON API
// ========================================================================

static char jsonBuf[JSON_BUF_SZ];

const char* buildSensorJson() {
    float brCur[4], brMx[4], brMn[4], brSum[4], brSumSq[4];
    long brCnt[4];
    float tiCur[4], tiMx[4], tiMn[4], tiSum[4], tiSumSq[4];
    long tiCnt[4];
    uint8_t sats;
    float spd, pdop;
    int32_t lat, lon;

    if (xSemaphoreTake(dataMutex, pdMS_TO_TICKS(10)) == pdTRUE) {
        for (int i = 0; i < 4; i++) {
            brCur[i] = sharedData.brakeCurrent[i];
            brMx[i] = sharedData.brakeMax[i];
            brMn[i] = sharedData.brakeMin[i];
            brSum[i] = sharedData.brakeSum[i];
            brSumSq[i] = sharedData.brakeSumSquares[i];
            brCnt[i] = sharedData.brakeReadingCounts[i];
            
            tiCur[i] = sharedData.tireCurrent[i];
            tiMx[i] = sharedData.tireMax[i];
            tiMn[i] = sharedData.tireMin[i];
            tiSum[i] = sharedData.tireSum[i];
            tiSumSq[i] = sharedData.tireSumSquares[i];
            tiCnt[i] = sharedData.tireReadingCounts[i];
        }
        sats = sharedData.sats;
        spd = sharedData.speed_kph;
        pdop = sharedData.pdop;
        lat = sharedData.lat_raw;
        lon = sharedData.lon_raw;
        xSemaphoreGive(dataMutex);
    } else {
        for (int i = 0; i < 4; i++) {
            brCur[i] = NAN; brMx[i] = NAN; brMn[i] = NAN; brSum[i] = 0; brSumSq[i] = 0; brCnt[i] = 0;
            tiCur[i] = NAN; tiMx[i] = NAN; tiMn[i] = NAN; tiSum[i] = 0; tiSumSq[i] = 0; tiCnt[i] = 0;
        }
        sats = 0; spd = 0; pdop = 99.99f; lat = 0; lon = 0;
    }

    auto fmt = [](float v, int dec, char* out) -> const char* {
        if (isnan(v)) { strcpy(out, "---.-"); return out; }
        dtostrf(v, 0, dec, out);
        return out;
    };

    char brCurStr[4][12], brAvgStr[4][12], brMaxStr[4][12], brMinStr[4][12], brStdStr[4][12];
    char tiCurStr[4][12], tiAvgStr[4][12], tiMaxStr[4][12], tiMinStr[4][12], tiStdStr[4][12];
    
    for (int i = 0; i < 4; i++) {
        fmt(brCur[i], 1, brCurStr[i]);
        fmt(tiCur[i], 1, tiCurStr[i]);
        
        float avg = (brCnt[i] > 0) ? brSum[i] / brCnt[i] : NAN;
        float var = (brCnt[i] > 1) ? (brSumSq[i] - (brSum[i] * brSum[i] / brCnt[i])) / (brCnt[i] - 1) : NAN;
        fmt(avg, 1, brAvgStr[i]);
        fmt(brMx[i], 1, brMaxStr[i]);
        fmt(brMn[i], 1, brMinStr[i]);
        fmt((var > 0) ? sqrtf(var) : NAN, 1, brStdStr[i]);
        
        avg = (tiCnt[i] > 0) ? tiSum[i] / tiCnt[i] : NAN;
        var = (tiCnt[i] > 1) ? (tiSumSq[i] - (tiSum[i] * tiSum[i] / tiCnt[i])) / (tiCnt[i] - 1) : NAN;
        fmt(avg, 1, tiAvgStr[i]);
        fmt(tiMx[i], 1, tiMaxStr[i]);
        fmt(tiMn[i], 1, tiMinStr[i]);
        fmt((var > 0) ? sqrtf(var) : NAN, 1, tiStdStr[i]);
    }

    char latS[20], lonS[20], spdS[12], pdopS[12];
    dtostrf((float)lat / 10000000.0f, 0, 6, latS);
    dtostrf((float)lon / 10000000.0f, 0, 6, lonS);
    dtostrf(spd, 0, 1, spdS);
    dtostrf(pdop, 0, 2, pdopS);

    snprintf(jsonBuf, JSON_BUF_SZ,
        "{\"br_fl_temp\":\"%s\",\"br_fr_temp\":\"%s\",\"br_rl_temp\":\"%s\",\"br_rr_temp\":\"%s\","
        "\"br_fl_avg\":\"%s\",\"br_fl_max\":\"%s\",\"br_fl_min\":\"%s\",\"br_fl_std\":\"%s\","
        "\"br_fr_avg\":\"%s\",\"br_fr_max\":\"%s\",\"br_fr_min\":\"%s\",\"br_fr_std\":\"%s\","
        "\"br_rl_avg\":\"%s\",\"br_rl_max\":\"%s\",\"br_rl_min\":\"%s\",\"br_rl_std\":\"%s\","
        "\"br_rr_avg\":\"%s\",\"br_rr_max\":\"%s\",\"br_rr_min\":\"%s\",\"br_rr_std\":\"%s\","
        "\"ti_fl_temp\":\"%s\",\"ti_fr_temp\":\"%s\",\"ti_rl_temp\":\"%s\",\"ti_rr_temp\":\"%s\","
        "\"ti_fl_avg\":\"%s\",\"ti_fl_max\":\"%s\",\"ti_fl_min\":\"%s\",\"ti_fl_std\":\"%s\","
        "\"ti_fr_avg\":\"%s\",\"ti_fr_max\":\"%s\",\"ti_fr_min\":\"%s\",\"ti_fr_std\":\"%s\","
        "\"ti_rl_avg\":\"%s\",\"ti_rl_max\":\"%s\",\"ti_rl_min\":\"%s\",\"ti_rl_std\":\"%s\","
        "\"ti_rr_avg\":\"%s\",\"ti_rr_max\":\"%s\",\"ti_rr_min\":\"%s\",\"ti_rr_std\":\"%s\","
        "\"sats\":%u,\"speed\":\"%s\",\"lat\":\"%s\",\"lon\":\"%s\",\"pdop\":\"%s\"}",
        brCurStr[0], brCurStr[1], brCurStr[2], brCurStr[3],
        brAvgStr[0], brMaxStr[0], brMinStr[0], brStdStr[0],
        brAvgStr[1], brMaxStr[1], brMinStr[1], brStdStr[1],
        brAvgStr[2], brMaxStr[2], brMinStr[2], brStdStr[2],
        brAvgStr[3], brMaxStr[3], brMinStr[3], brStdStr[3],
        tiCurStr[0], tiCurStr[1], tiCurStr[2], tiCurStr[3],
        tiAvgStr[0], tiMaxStr[0], tiMinStr[0], tiStdStr[0],
        tiAvgStr[1], tiMaxStr[1], tiMinStr[1], tiStdStr[1],
        tiAvgStr[2], tiMaxStr[2], tiMinStr[2], tiStdStr[2],
        tiAvgStr[3], tiMaxStr[3], tiMinStr[3], tiStdStr[3],
        sats, spdS, latS, lonS, pdopS
    );
    return jsonBuf;
}

// ========================================================================
// WEB SERVER SETUP
// ========================================================================

void setupWebServer() {
    server.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
        request->send_P(200, "text/html", index_html);
    });

    server.on("/data", HTTP_GET, [](AsyncWebServerRequest *request) {
        request->send(200, "application/json", buildSensorJson());
    });

    server.on("/logslist", HTTP_GET, [](AsyncWebServerRequest *request) {
        if (!isSdCardAvailable) { request->send(200, "application/json", "[]"); return; }
        File root = SD.open("/");
        String json = "[";
        bool first = true;
        if (root) {
            File file = root.openNextFile();
            while (file) {
                const char* fileName = file.name();
                if (!file.isDirectory() && strncmp(fileName, "log_", 4) == 0 && strstr(fileName, ".csv")) {
                    if (!first) json += ",";
                    json += "\"" + String(fileName) + "\"";
                    first = false;
                }
                file.close();
                file = root.openNextFile();
            }
            root.close();
        }
        json += "]";
        request->send(200, "application/json", json);
    });

    server.on("/view", HTTP_GET, [](AsyncWebServerRequest *request) {
        if (request->hasParam("file")) {
            String path = "/" + request->getParam("file")->value();
            if (isSdCardAvailable && SD.exists(path)) request->send(SD, path.c_str(), "text/plain");
            else request->send(404, "text/plain", "File not found");
        } else request->send(400, "text/plain", "Missing file parameter");
    });

    server.on("/download", HTTP_GET, [](AsyncWebServerRequest *request) {
        if (request->hasParam("file")) {
            String path = "/" + request->getParam("file")->value();
            if (isSdCardAvailable && SD.exists(path)) request->send(SD, path.c_str(), "text/csv", true);
            else request->send(404, "text/plain", "File not found");
        } else request->send(400, "text/plain", "Missing file parameter");
    });

    server.on("/reboot", HTTP_POST, [](AsyncWebServerRequest *request) {
        request->send(200, "text/plain", "Rebooting");
        delay(100);
        ESP.restart();
    });

    server.begin();
}

// ========================================================================
// DISPLAY FUNCTIONS
// ========================================================================

int16_t gridW, gridH, colW, rowH;

void setupTFTGridLayout() {
    tft.fillScreen(ILI9341_BLACK);

    gridW = tft.width();
    gridH = tft.height();
    colW  = gridW / 4;
    rowH  = gridH / 4;

    // Draw grid lines
    for (int c = 1; c < 4; ++c) tft.drawFastVLine(c * colW, 0, gridH, ILI9341_ORANGE);
    for (int r = 1; r < 4; ++r) tft.drawFastHLine(0, r * rowH, gridW, ILI9341_ORANGE);

    auto centerX  = [&](int col){ return col * colW + (colW/2) - 24; };
    auto baseline = [&](int row){ return row * rowH + (rowH/2) - 12; };
    auto cellRect = [&](int row, int col)->Rect{
        return Rect{ col*colW + 1, row*rowH + 1, colW - 2, rowH - 2 };
    };

    tft.setTextSize(TEMP_TEXT_SIZE);
    tft.setTextColor(ILI9341_WHITE, ILI9341_BLACK);

    // FRONT ROW (Standard layout: Temp above, Color below)
    tireTextPos[FL_INDEX]  = { centerX(0), baseline(0) };
    brakeTextPos[FL_INDEX] = { centerX(1), baseline(0) };
    brakeTextPos[FR_INDEX] = { centerX(2), baseline(0) };
    tireTextPos[FR_INDEX]  = { centerX(3), baseline(0) };

    tireColorCell[FL_INDEX]  = cellRect(1, 0);
    brakeColorCell[FL_INDEX] = cellRect(1, 1);
    brakeColorCell[FR_INDEX] = cellRect(1, 2);
    tireColorCell[FR_INDEX]  = cellRect(1, 3);

    // REAR ROW (Inverted: Color above, Temp below)
    tireColorCell[RL_INDEX]  = cellRect(2, 0);
    brakeColorCell[RL_INDEX] = cellRect(2, 1);
    brakeColorCell[RR_INDEX] = cellRect(2, 2);
    tireColorCell[RR_INDEX]  = cellRect(2, 3);

    tireTextPos[RL_INDEX]  = { centerX(0), baseline(3) };
    brakeTextPos[RL_INDEX] = { centerX(1), baseline(3) };
    brakeTextPos[RR_INDEX] = { centerX(2), baseline(3) };
    tireTextPos[RR_INDEX]  = { centerX(3), baseline(3) };

    for (int i = 0; i < 4; i++) {
        strcpy(prevTireStrings[i], "INIT");
        strcpy(prevBrakeStrings[i], "INIT");
    }
}

uint16_t getTempColor(float t) {
    if (isnan(t) || t < -900 || t > 999) return ILI9341_WHITE;
    if (t <= 50)  return ILI9341_BLUE;
    if (t <= 100) return ILI9341_GREEN;
    if (t <= 200) return ILI9341_YELLOW;
    if (t <= 300) return ILI9341_RED;
    return ILI9341_RED;
}

void drawTempAt(const CellPos& pos, const char* text) {
    tft.setTextSize(TEMP_TEXT_SIZE);
    tft.setTextColor(ILI9341_WHITE, ILI9341_BLACK);
    tft.setCursor(pos.x, pos.y);
    tft.print(text);
}

void fillCellRect(const Rect& r, uint16_t color, bool flashWhenHot) {
    uint16_t c = color;
    if (flashWhenHot && !flashState) c = ILI9341_BLACK;
    tft.fillRect(r.x, r.y, r.w, r.h, c);
}

void updateTempDisplay_Tire(int idx, float t) {
    if (idx < 0 || idx >= 4) return;
    char s[8];
    if (isnan(t) || t < -900 || t > 999) strcpy(s, "---");
    else snprintf(s, sizeof(s), "%03.0f", t);
    if (strcmp(prevTireStrings[idx], s) != 0) {
        drawTempAt(tireTextPos[idx], s);
        strcpy(prevTireStrings[idx], s);
    }
}

void updateTempDisplay_Brake(int idx, float t) {
    if (idx < 0 || idx >= 4) return;
    char s[8];
    if (isnan(t) || t < -900 || t > 999) strcpy(s, "---");
    else snprintf(s, sizeof(s), "%03.0f", t);
    if (strcmp(prevBrakeStrings[idx], s) != 0) {
        drawTempAt(brakeTextPos[idx], s);
        strcpy(prevBrakeStrings[idx], s);
    }
}

void updateColorCell_Tire(int idx, float t) {
    if (idx < 0 || idx >= 4) return;
    uint16_t col = getTempColor(t);
    bool flashHot = (!isnan(t) && t > 300);
    fillCellRect(tireColorCell[idx], col, flashHot);
}

void updateColorCell_Brake(int idx, float t) {
    if (idx < 0 || idx >= 4) return;
    uint16_t col = getTempColor(t);
    bool flashHot = (!isnan(t) && t > 300);
    fillCellRect(brakeColorCell[idx], col, flashHot);
}

// ========================================================================
// FREERTOS TASKS
// ========================================================================

void sensorAndLogTask(void *parameter) {
    const TickType_t per = pdMS_TO_TICKS(SENSOR_LOG_TASK_PERIOD);
    TickType_t xLast = xTaskGetTickCount();
    twai_message_t rx_msg;

    Serial.println("Sensor task started on Core 0");

    for (;;) {
        // CAN bus message processing (optimized burst drain)
        for (int i = 0; i < CAN_BURST_DRAIN; ++i) {
            if (twai_receive(&rx_msg, 0) != ESP_OK) break;

            float tC;
            if (!decodeTempBE_i16x100(rx_msg, tC)) continue;

            int tidx = tireIdToIndex(rx_msg.identifier);
            int bidx = brakeIdToIndex(rx_msg.identifier);

            if (tidx != -1 || bidx != -1) {
                if (xSemaphoreTake(dataMutex, pdMS_TO_TICKS(2)) == pdTRUE) {
                    if (tidx != -1) {
                        sharedData.tireCurrent[tidx] = tC;
                        if (!isnan(tC)) {
                            if (sharedData.tireMax[tidx] < -500 || tC > sharedData.tireMax[tidx]) 
                                sharedData.tireMax[tidx] = tC;
                            if (sharedData.tireMin[tidx] > 500 || tC < sharedData.tireMin[tidx]) 
                                sharedData.tireMin[tidx] = tC;
                            sharedData.tireSum[tidx] += tC;
                            sharedData.tireSumSquares[tidx] += tC * tC;
                            sharedData.tireReadingCounts[tidx]++;
                        }
                    }
                    if (bidx != -1) {
                        sharedData.brakeCurrent[bidx] = tC;
                        if (!isnan(tC)) {
                            if (sharedData.brakeMax[bidx] < -500 || tC > sharedData.brakeMax[bidx]) 
                                sharedData.brakeMax[bidx] = tC;
                            if (sharedData.brakeMin[bidx] > 500 || tC < sharedData.brakeMin[bidx]) 
                                sharedData.brakeMin[bidx] = tC;
                            sharedData.brakeSum[bidx] += tC;
                            sharedData.brakeSumSquares[bidx] += tC * tC;
                            sharedData.brakeReadingCounts[bidx]++;
                        }
                    }
                    xSemaphoreGive(dataMutex);
                }
            }
        }

        // GNSS + SD logging
        if (gnssConfigured && myGNSS.getPVT()) {
            struct { float br[4], ti[4]; int32_t lat, lon; float spd; uint8_t sats; float pdop; bool tValid; } s;
            s.lat = myGNSS.getLatitude();
            s.lon = myGNSS.getLongitude();
            s.spd = (float)myGNSS.getGroundSpeed() * 0.0036f;
            s.sats = myGNSS.getSIV();
            s.pdop = (float)myGNSS.getPDOP() / 100.0f;
            s.tValid = myGNSS.getTimeValid();

            if (xSemaphoreTake(dataMutex, pdMS_TO_TICKS(2)) == pdTRUE) {
                for (int i = 0; i < 4; i++) { 
                    s.br[i] = sharedData.brakeCurrent[i]; 
                    s.ti[i] = sharedData.tireCurrent[i]; 
                }
                sharedData.lat_raw = s.lat;
                sharedData.lon_raw = s.lon;
                sharedData.speed_kph = s.spd;
                sharedData.sats = s.sats;
                sharedData.pdop = s.pdop;
                sharedData.gnssValid = myGNSS.getFixType() >= 2;
                sharedData.newPVTAvailable = true;
                sharedData.lastPVTTime = millis();
                xSemaphoreGive(dataMutex);
            }

            if (isSdCardAvailable && logFile) {
                char dateBuf[12], timeBuf[13];
                char brFR[8], brFL[8], brRR[8], brRL[8];
                char tiFR[8], tiFL[8], tiRR[8], tiRL[8];
                char lat[14], lon[14], spd[10], pd[8], line[300];

                if (myGNSS.getYear() > 2020) sprintf(dateBuf, "%04d-%02d-%02d", myGNSS.getYear(), myGNSS.getMonth(), myGNSS.getDay());
                else strcpy(dateBuf, "0000-00-00");
                if (s.tValid) sprintf(timeBuf, "%02d:%02d:%02d.%03d", myGNSS.getHour(), myGNSS.getMinute(), myGNSS.getSecond(), myGNSS.getMillisecond());
                else strcpy(timeBuf, "00:00:00.000");

                auto f2s = [](float v, char*o, int w, int d) { dtostrf(isnan(v) ? -1.0 : v, w, d, o); };
                f2s(s.br[FR_INDEX], brFR, 6, 2);
                f2s(s.br[FL_INDEX], brFL, 6, 2);
                f2s(s.br[RR_INDEX], brRR, 6, 2);
                f2s(s.br[RL_INDEX], brRL, 6, 2);
                f2s(s.ti[FR_INDEX], tiFR, 6, 2);
                f2s(s.ti[FL_INDEX], tiFL, 6, 2);
                f2s(s.ti[RR_INDEX], tiRR, 6, 2);
                f2s(s.ti[RL_INDEX], tiRL, 6, 2);
                dtostrf((float)s.lat / 10000000.0f, 0, 6, lat);
                dtostrf((float)s.lon / 10000000.0f, 0, 6, lon);
                dtostrf(s.spd, 0, 2, spd);
                dtostrf(s.pdop, 0, 2, pd);

                snprintf(line, sizeof(line), "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%u,%s",
                         dateBuf, timeBuf, brFR, brFL, brRR, brRL, tiFR, tiFL, tiRR, tiRL, lat, lon, spd, s.sats, pd);
                logFile.println(line);
                if (++bufferedLines >= SD_FLUSH_LINES || (millis() - lastFlushMs) >= SD_FLUSH_INTERVAL_MS) {
                    logFile.flush();
                    bufferedLines = 0;
                    lastFlushMs = millis();
                }
            }
        }

        vTaskDelayUntil(&xLast, per);
    }
}

void displayUpdateTask(void *parameter) {
    const TickType_t per = pdMS_TO_TICKS(DISPLAY_UPDATE_TASK_PERIOD);
    TickType_t xLast = xTaskGetTickCount();

    Serial.println("Display task started on Core 1");

    for (;;) {
        float brCur[4], tiCur[4];
        unsigned long ts;

        if (xSemaphoreTake(dataMutex, pdMS_TO_TICKS(2)) == pdTRUE) {
            for (int i = 0; i < 4; i++) {
                brCur[i] = sharedData.brakeCurrent[i];
                tiCur[i] = sharedData.tireCurrent[i];
            }
            ts = millis();
            xSemaphoreGive(dataMutex);
        } else {
            for (int i = 0; i < 4; i++) { brCur[i] = NAN; tiCur[i] = NAN; }
            ts = millis();
        }

        flashState = (ts % (FLASH_INTERVAL * 2) < FLASH_INTERVAL);

        updateTempDisplay_Tire(FL_INDEX, tiCur[FL_INDEX]);
        updateTempDisplay_Tire(FR_INDEX, tiCur[FR_INDEX]);
        updateTempDisplay_Tire(RL_INDEX, tiCur[RL_INDEX]);
        updateTempDisplay_Tire(RR_INDEX, tiCur[RR_INDEX]);

        updateTempDisplay_Brake(FL_INDEX, brCur[FL_INDEX]);
        updateTempDisplay_Brake(FR_INDEX, brCur[FR_INDEX]);
        updateTempDisplay_Brake(RL_INDEX, brCur[RL_INDEX]);
        updateTempDisplay_Brake(RR_INDEX, brCur[RR_INDEX]);

        updateColorCell_Tire(FL_INDEX, tiCur[FL_INDEX]);
        updateColorCell_Brake(FL_INDEX, brCur[FL_INDEX]);
        updateColorCell_Brake(FR_INDEX, brCur[FR_INDEX]);
        updateColorCell_Tire(FR_INDEX, tiCur[FR_INDEX]);

        updateColorCell_Tire(RL_INDEX, tiCur[RL_INDEX]);
        updateColorCell_Brake(RL_INDEX, brCur[RL_INDEX]);
        updateColorCell_Brake(RR_INDEX, brCur[RR_INDEX]);
        updateColorCell_Tire(RR_INDEX, tiCur[RR_INDEX]);

        vTaskDelayUntil(&xLast, per);
    }
}

// ========================================================================
// SETUP
// ========================================================================

void setup() {
    Serial.begin(115200);
    Serial.println("\n=== BTTM v1.9.1 Production - ESP32-S3 Starting ===");

    pinMode(HEARTBEAT_LED, OUTPUT);
    digitalWrite(HEARTBEAT_LED, HIGH);

    initializeSharedData();
    dataMutex = xSemaphoreCreateMutex();
    if (dataMutex == NULL) { 
        Serial.println("FATAL: Failed to create data mutex!"); 
        while (1); 
    }

    // TFT Display
    SPI.begin(TFT_SCLK, TFT_MISO, TFT_MOSI);
    SPI.setFrequency(32000000);
    tft.begin();
    tft.setRotation(3);
    tft.fillScreen(ILI9341_BLACK);
    tft.setTextColor(ILI9341_WHITE);
    tft.setTextSize(2);
    tft.setCursor(10, 80);
    tft.println(version_text);

    // SD Card
    tft.setCursor(10, 110);
    tft.print("SD Card: Initializing...");
    isSdCardAvailable = initializeSDCard();
    tft.setTextColor(isSdCardAvailable ? ILI9341_GREEN : ILI9341_RED);
    tft.println(isSdCardAvailable ? " OK!" : " FAILED!");
    vTaskDelay(pdMS_TO_TICKS(1000));

    // WiFi
    tft.fillScreen(ILI9341_BLACK);
    tft.setTextSize(2);
    tft.setTextColor(ILI9341_WHITE);
    tft.setCursor(10, 100);
    tft.print("WiFi connecting...");
    WiFi.begin(ssid, password);
    int wifiAttempts = 0;
    while (WiFi.status() != WL_CONNECTED && wifiAttempts < 20) {
        vTaskDelay(pdMS_TO_TICKS(500));
        Serial.print(".");
        wifiAttempts++;
    }
    if (WiFi.status() == WL_CONNECTED) {
        Serial.printf("\nWiFi connected! IP: %s\n", WiFi.localIP().toString().c_str());
        tft.setTextColor(ILI9341_GREEN); 
        tft.println(" OK!");
        tft.setTextSize(1); 
        tft.setCursor(10, 130);
        tft.printf("IP: %s", WiFi.localIP().toString().c_str());
    } else {
        Serial.println("\nWiFi connection failed - continuing without web server");
        tft.setTextColor(ILI9341_RED); 
        tft.println(" FAILED!");
    }
    vTaskDelay(pdMS_TO_TICKS(2000));

    // CAN Bus
    twai_general_config_t g_cfg = TWAI_GENERAL_CONFIG_DEFAULT((gpio_num_t)CAN_TX_PIN, (gpio_num_t)CAN_RX_PIN, TWAI_MODE_NORMAL);
    g_cfg.tx_queue_len = 10; 
    g_cfg.rx_queue_len = 32; 
    g_cfg.alerts_enabled = TWAI_ALERT_AND_LOG; 
    g_cfg.clkout_divider = 0;
    twai_timing_config_t t_cfg = TWAI_TIMING_CONFIG_500KBITS();
    twai_filter_config_t f_cfg = TWAI_FILTER_CONFIG_ACCEPT_ALL();
    if (twai_driver_install(&g_cfg, &t_cfg, &f_cfg) == ESP_OK && twai_start() == ESP_OK) { 
        isCanBusOk = true; 
    } else { 
        isCanBusOk = false; 
    }

    // GNSS
    gnssConfigured = configureGNSS_5Hz();

    // Web Server
    if (WiFi.status() == WL_CONNECTED) { 
        setupWebServer();
        Serial.println("Web server started");
    }

    // TFT Grid Layout
    setupTFTGridLayout();

    // FreeRTOS Tasks
    xTaskCreatePinnedToCore(
        sensorAndLogTask,
        "SensorTask",
        SENSOR_LOG_TASK_STACK,
        NULL,
        SENSOR_LOG_TASK_PRIORITY,
        &sensorLogTaskHandle,
        0  // Core 0
    );
    
    xTaskCreatePinnedToCore(
        displayUpdateTask,
        "DisplayTask",
        DISPLAY_UPDATE_TASK_STACK,
        NULL,
        DISPLAY_UPDATE_TASK_PRIORITY,
        &displayUpdateTaskHandle,
        1  // Core 1
    );

    Serial.println("=== BTTM v1.9.1 Ready ===");
}

// ========================================================================
// MAIN LOOP
// ========================================================================

void loop() {
    static unsigned long lastHb = 0;
    if (millis() - lastHb >= 500) { 
        lastHb = millis(); 
        digitalWrite(HEARTBEAT_LED, !digitalRead(HEARTBEAT_LED)); 
    }
    delay(10);
}
